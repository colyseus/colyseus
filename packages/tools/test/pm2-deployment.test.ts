/**
 * PM2 Deployment Test Suite (Mocha)
 *
 * Tests that the post-deploy logic respects the `instances` configuration
 * from ecosystem.config.js and doesn't scale to os.cpus().length.
 *
 * Usage:
 *   npx mocha --import tsx test/pm2-deployment.test.ts --timeout 60000
 */
import pm2 from 'pm2';
import path from 'path';
import fs from 'fs';
import os from 'os';
import assert from 'assert';

const TEST_DIR = __dirname;
const ECOSYSTEM_CONFIG_PATH = path.join(TEST_DIR, 'ecosystem.config.cjs');
const TEST_NGINX_CONFIG_PATH = path.join(TEST_DIR, 'test_colyseus_servers.conf');

// Path to the local @colyseus/tools package for PM2 module installation
const TOOLS_PACKAGE_PATH = path.resolve(__dirname, '..');

const PM2_APP_NAME = 'my-app';

/**
 * Set environment variables for test NGINX config path
 */
process.env.NGINX_CONFIG_FILE = TEST_NGINX_CONFIG_PATH;

/**
 * Update ecosystem config with specified number of instances
 */
function updateEcosystemConfig(instances: number): void {
  const configContent = `/**
 * Ecosystem config for testing PM2 deployment with specific instance count.
 * Auto-generated by test script.
 */
module.exports = {
  apps: [{
    name: '${PM2_APP_NAME}',
    script: './dummy-server.cjs',
    instances: ${instances},
  }]
};
`;
  fs.writeFileSync(ECOSYSTEM_CONFIG_PATH, configContent);
}

/**
 * List running apps (excluding @colyseus/tools)
 */
function listApps(): Promise<pm2.ProcessDescription[]> {
  return new Promise((resolve, reject) => {
    pm2.list((err, apps) => {
      if (err) return reject(err);
      const testApps = apps.filter(app => app.name === PM2_APP_NAME);
      resolve(testApps);
    });
  });
}

/**
 * Wait for apps to reach expected count and status
 */
function waitForApps(expectedCount: number, status = 'online', timeout = 15000): Promise<pm2.ProcessDescription[]> {
  return new Promise((resolve, reject) => {
    const startTime = Date.now();

    const check = async () => {
      try {
        const apps = await listApps();
        const matchingApps = apps.filter(app => app.pm2_env?.status === status);

        if (matchingApps.length === expectedCount) {
          resolve(matchingApps);
        } else if (Date.now() - startTime > timeout) {
          reject(new Error(
            `Timeout: Expected ${expectedCount} ${status} apps, got ${matchingApps.length} ` +
            `(total apps: ${apps.length})`
          ));
        } else {
          setTimeout(check, 500);
        }
      } catch (err) {
        reject(err);
      }
    };

    check();
  });
}

/**
 * Clean up all test processes
 */
function cleanup(): Promise<void> {
  return new Promise((resolve) => {
    pm2.delete(PM2_APP_NAME, () => resolve());
  });
}

/**
 * Get fresh shared module (clears cache)
 */
function getSharedModule() {
  delete require.cache[require.resolve('../pm2/shared')];
  return require('../pm2/shared');
}

/**
 * Install @colyseus/tools as a PM2 module by starting the agent script directly
 */
function installPostDeployAgent(): Promise<void> {
  return new Promise((resolve, reject) => {
    const agentPath = path.resolve(TOOLS_PACKAGE_PATH, 'pm2/post-deploy-agent.cjs');
    pm2.start({
      name: '@colyseus/tools',
      script: agentPath,
      cwd: TOOLS_PACKAGE_PATH,
    }, (err) => {
      if (err) return reject(err);
      // Wait for the module to initialize
      setTimeout(resolve, 2000);
    });
  });
}

/**
 * Uninstall @colyseus/tools PM2 module
 */
function uninstallPostDeployAgent(): Promise<void> {
  return new Promise((resolve) =>
      pm2.delete('@colyseus/tools', () => resolve()));
}

/**
 * Trigger post-deploy action via the PM2 module
 * This mimics what `colyseus-post-deploy` script does
 */
function triggerPostDeploy(cwd: string, ecosystemPath: string): Promise<{ success: boolean; message?: string }> {
  return new Promise((resolve, reject) => {
    (pm2 as any).trigger('@colyseus/tools', 'post-deploy', `${cwd}:${ecosystemPath}`, (err: Error | null, result: any) => {
      if (err) {
        return reject(err);
      }
      const returnData = result?.[0]?.data?.return;
      if (returnData?.success === false) {
        return reject(new Error(returnData?.message || 'Post-deploy failed'));
      }
      resolve(returnData || { success: true });
    });
  });
}

xdescribe('PM2 Deployment', function () {
  this.timeout(60000); // 60 second timeout for all tests

  const EXPECTED_INSTANCES = 1;

  before(async function () {
    console.log(`\n  System info:`);
    console.log(`    CPU cores: ${os.cpus().length}`);
    console.log(`    Expected instances: ${EXPECTED_INSTANCES}`);
    console.log(`    Test directory: ${TEST_DIR}`);
    console.log(`    Test NGINX config: ${TEST_NGINX_CONFIG_PATH}\n`);

    // Update ecosystem config
    updateEcosystemConfig(EXPECTED_INSTANCES);

    // Connect to PM2
    await new Promise<void>((resolve, reject) => {
      pm2.connect((err) => {
        if (err) return reject(err);
        resolve();
      });
    });

    // Clean up any existing test processes
    await cleanup();

    // Install @colyseus/tools as PM2 module
    console.log('    Installing @colyseus/tools PM2 module...');
    await installPostDeployAgent();
    console.log('    PM2 module installed successfully.\n');
  });

  after(async function () {
    await cleanup();

    // Uninstall @colyseus/tools PM2 module
    console.log('    Uninstalling @colyseus/tools PM2 module...');
    await uninstallPostDeployAgent();

    // Clean up test files
    if (fs.existsSync(TEST_NGINX_CONFIG_PATH)) {
      fs.unlinkSync(TEST_NGINX_CONFIG_PATH);
    }

    pm2.disconnect();
  });

  beforeEach(function (done) {
    // Small delay between tests
    setTimeout(done, 500);
  });

  describe('Fresh Deployment', function () {
    it(`should start exactly ${1} instance(s) on first deploy`, async function () {
      // Clean slate
      await cleanup();

      // Trigger post-deploy via PM2 module (first deploy - will start apps)
      await triggerPostDeploy(TEST_DIR, ECOSYSTEM_CONFIG_PATH);

      // Wait for apps to be online
      const apps = await waitForApps(EXPECTED_INSTANCES);

      console.log(`      Running instances: ${apps.length}`);
      apps.forEach(app => {
        console.log(`        - Instance ${(app.pm2_env as any)?.NODE_APP_INSTANCE}: PID ${app.pid}`);
      });

      assert.strictEqual(
        apps.length,
        EXPECTED_INSTANCES,
        `Expected ${EXPECTED_INSTANCES} instances, got ${apps.length}`
      );
    });
  });

  describe('Continuous Deployment (reload)', function () {
    it(`should maintain exactly ${1} instance(s) after reload`, async function () {
      // Trigger post-deploy via PM2 module (simulates re-deploy with reload)
      await triggerPostDeploy(TEST_DIR, ECOSYSTEM_CONFIG_PATH);

      // Wait a bit for reload to complete
      await new Promise(resolve => setTimeout(resolve, 2000));

      // Wait for apps to be online
      const apps = await waitForApps(EXPECTED_INSTANCES);

      console.log(`      Running instances: ${apps.length}`);
      apps.forEach(app => {
        console.log(`        - Instance ${(app.pm2_env as any)?.NODE_APP_INSTANCE}: PID ${app.pid}`);
      });

      assert.strictEqual(
        apps.length,
        EXPECTED_INSTANCES,
        `Expected ${EXPECTED_INSTANCES} instances, got ${apps.length}`
      );
    });
  });

  describe('Multiple Consecutive Deployments', function () {
    const DEPLOY_COUNT = 3;

    it(`should not grow beyond ${1} instance(s) after ${3} deploys`, async function () {
      for (let i = 1; i <= DEPLOY_COUNT; i++) {
        console.log(`      Deployment ${i}/${DEPLOY_COUNT}...`);

        // Trigger post-deploy via PM2 module
        await triggerPostDeploy(TEST_DIR, ECOSYSTEM_CONFIG_PATH);

        await new Promise(resolve => setTimeout(resolve, 1500));

        const apps = await listApps();
        const onlineApps = apps.filter(app => app.pm2_env?.status === 'online');

        console.log("ONLINE APPS:", onlineApps);

        console.log(`        Online instances: ${onlineApps.length}`);

        // Check if instances grew unexpectedly
        if (onlineApps.length > EXPECTED_INSTANCES) {
          assert.fail(
            `BUG: After deployment ${i}, instances grew from ${EXPECTED_INSTANCES} to ${onlineApps.length}`
          );
        }
      }

      const finalApps = await listApps();
      const onlineApps = finalApps.filter(app => app.pm2_env?.status === 'online');

      assert.strictEqual(
        onlineApps.length,
        EXPECTED_INSTANCES,
        `After ${DEPLOY_COUNT} deployments: Expected ${EXPECTED_INSTANCES} instances, got ${onlineApps.length}`
      );
    });
  });

  describe('Config Instances Property', function () {
    it('should preserve user-specified instances value in config', async function () {
      const cpuCount = os.cpus().length;

      if (cpuCount <= EXPECTED_INSTANCES) {
        this.skip();
        return;
      }

      const shared = getSharedModule();
      const config = await shared.getAppConfig(ECOSYSTEM_CONFIG_PATH);

      console.log(`      CPU count: ${cpuCount}`);
      console.log(`      Config instances: ${config.apps[0].instances}`);

      assert.strictEqual(
        config.apps[0].instances,
        EXPECTED_INSTANCES,
        `Config instances should be ${EXPECTED_INSTANCES}, got ${config.apps[0].instances}`
      );
    });

    it('should NOT default to os.cpus().length when instances is specified', async function () {
      const cpuCount = os.cpus().length;

      if (cpuCount === EXPECTED_INSTANCES) {
        this.skip();
        return;
      }

      const shared = getSharedModule();
      const config = await shared.getAppConfig(ECOSYSTEM_CONFIG_PATH);

      assert.notStrictEqual(
        config.apps[0].instances,
        cpuCount,
        `Config instances should NOT be ${cpuCount} (os.cpus().length)`
      );
    });
  });
});
